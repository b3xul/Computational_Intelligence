# Old version

| N    | Solution length | Nodes visited |
| ---- | --------------- | ------------- |
| 5    | 5               | 83            |
| 10   | 10              | 194540        |
| 20   | 23              | 1433700       |
| 100  | x               | x             |
| 500  | x               | x             |
| 1000 | x               | x             |

After >10h of work I was not able to create a better solution than this very bad one. It just avoids sets that don't add
more coverage.

Credits:  
https://stackoverflow.com/questions/60114801/find-minimal-set-of-subsets-that-covers-a-given-set

# Improved version

| N    | Solution length | Nodes visited | Time taken (s) |
| ---- | --------------- | ------------- | -------------- |
| 5    | 5               | 4             | 0.001          |
| 10   | 10              | 37            | 0.015          |
| 20   | 23              | 919           | 0.524          |
| 30   | 37              | 37115         | 97.612         |
| 40   | 54              | 59381         | 122.364        |
| 50   | x               | x             | x              |
| 100  | x               | x             | x              |
| 500  | x               | x             | x              |
| 1000 | x               | x             | x              |

I took inspiration from the Professor's solution regarding the data structures used for the solution. Each state is
represented by a tuple of tuples. Before starting the search I remove all duplicates from the initial lists generated by
the problem function. Then I count how many times each number up to N appears in the lists, and add to the initial state
all the lists that are the only ones that contain a certain number, since they will surely be part of the solution.
During the search I only add to the frontier states that include a new combination of distinct numbers, or that improve
the cost to obtain that combination of distinct numbers. The cost of each state is given by the total number of elements
in that state divided by the amount of distinct values it covers. At each step we add to the current solution the state
with minimum cost, until we reach the solution.

The algorithm works pretty well up to N=40. After that, the memory required to store all the state_costs dictionary
grows too much, so it is not able to find a solution.